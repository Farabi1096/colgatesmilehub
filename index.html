<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outlet Tracker - Bangladesh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS for map styling -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        colgate: {
                            red: '#E01933',
                            dark: '#8E0016',
                            blue: '#002169',
                            lightBlue: '#E6F0FA',
                        }
                    },
                    fontFamily: {
                        sans: ['"Open Sans"', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom CSS for layout and map container */
        body {
            background-color: #F3F4F6;
            color: #4B5563;
        }
        
        /* Map Styles */
        #map {
            height: 550px; 
            width: 100%;
            border-radius: 1rem;
            z-index: 1;
            background: #e5e7eb; 
        }

        /* Minimalistic Input Styles */
        .min-input {
            background-color: #FFFFFF;
            border: 1px solid #E5E7EB;
            transition: all 0.2s ease;
        }
        .min-input:focus {
            background-color: #FFFFFF;
            border-color: #E01933;
            outline: none;
            box-shadow: 0 0 0 1px #E01933;
        }

        /* Custom Scrollbar (Red Theme) */
        .custom-scrollbar::-webkit-scrollbar {
            width: 5px;
            height: 5px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: transparent;
        }

        .leaflet-control-container {
            visibility: hidden;
        }
        
        .invalid-list-item {
            border-left: 3px solid #E01933;
            background-color: #FFF1F2;
        }

        /* KPI Card Styling */
        .kpi-card {
            background: white;
            border: 1px solid #F3F4F6;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .kpi-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
        }
        .kpi-red::before { background-color: #E01933; }
        .kpi-blue::before { background-color: #002169; }

        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.05);
        }

        /* Checkbox Styling for Routes */
        .route-checkbox:checked + div {
            background-color: #E01933;
            border-color: #E01933;
        }
        .route-checkbox:checked + div svg {
            display: block;
        }

        /* Fade in animation */
        .fade-in {
            animation: fadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-start py-8 px-4 md:px-6">

    <!-- Main Container -->
    <div class="w-full max-w-6xl fade-in grid grid-cols-1 lg:grid-cols-12 gap-6 items-stretch">
        
        <!-- Header -->
        <div class="lg:col-span-12 mb-2 flex items-center justify-between">
            <div>
                <h1 class="text-2xl md:text-3xl font-extrabold text-colgate-red tracking-tight leading-none">
                    ColgateSmile <span class="text-colgate-blue">Hubs</span>
                </h1>
                <p class="text-xs text-gray-500 font-semibold uppercase tracking-wide mt-1">Bangladesh Retail Mapping</p>
            </div>
             <div id="system-status" class="hidden md:flex items-center gap-2 px-3 py-1 bg-white rounded-full border border-gray-200 shadow-sm">
                <span class="relative flex h-2 w-2">
                  <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-blue-400 opacity-75"></span>
                  <span class="relative inline-flex rounded-full h-2 w-2 bg-blue-500"></span>
                </span>
                <span id="connection-text" class="text-xs font-bold text-gray-600">Connecting...</span>
            </div>
        </div>

        <!-- Left Column: Controls (Inputs & Filters) -->
        <div class="lg:col-span-3 flex flex-col gap-4 h-full">

            <!-- Filters Section -->
            <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 shrink-0 relative z-50">
                <h2 class="text-gray-800 font-bold text-sm mb-3 flex items-center gap-2 uppercase tracking-wide">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-colgate-red" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
                    </svg>
                    Filters
                </h2>
                
                <div class="space-y-3">
                    <div class="relative">
                        <input type="text" id="search-input" placeholder="Search..." class="min-input w-full pl-8 p-2 rounded-lg text-xs font-medium">
                        <svg class="w-3 h-3 absolute left-3 top-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    </div>
                    
                    <select id="filter-area" class="min-input w-full p-2 rounded-lg text-xs text-gray-600"><option value="">All Areas</option></select>
                    <select id="filter-territory" class="min-input w-full p-2 rounded-lg text-xs text-gray-600"><option value="">All Territories</option></select>
                    <select id="filter-town" class="min-input w-full p-2 rounded-lg text-xs text-gray-600"><option value="">All Towns</option></select>
                    
                    <!-- NEW MULTI-SELECT ROUTE FILTER -->
                    <div class="relative">
                        <button id="route-multiselect-btn" class="min-input w-full p-2 rounded-lg text-xs text-gray-600 text-left flex justify-between items-center bg-white cursor-pointer">
                            <span id="route-btn-text" class="truncate">All Routes</span>
                            <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        
                        <!-- Dropdown Content -->
                        <div id="route-dropdown-list" class="hidden absolute z-50 w-full bg-white border border-gray-200 rounded-lg shadow-xl mt-1 max-h-60 overflow-y-auto p-2 custom-scrollbar">
                            <!-- JS will populate checkboxes here -->
                            <div class="text-xs text-gray-400 text-center py-2">Select Town first</div>
                        </div>
                    </div>
                    
                    <button id="clear-filters-btn" class="w-full text-[10px] text-gray-400 hover:text-colgate-red transition-colors font-bold uppercase tracking-wider py-1 border-t border-dashed border-gray-200 mt-2">
                        Reset All
                    </button>
                    
                    <!-- Sync Button -->
                    <button id="sync-btn" class="w-full mt-4 flex items-center justify-center gap-2 bg-blue-50 border border-blue-200 text-blue-600 hover:bg-blue-100 transition-all rounded-lg py-2.5 text-xs font-bold uppercase tracking-wider shadow-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                        Force Cloud Sync
                    </button>

                    <!-- Clear Local Button -->
                    <button id="clear-local-data-btn" class="w-full mt-2 flex items-center justify-center gap-2 bg-white border border-gray-300 text-gray-600 hover:bg-gray-50 hover:border-gray-400 transition-all rounded-lg py-2.5 text-xs font-bold uppercase tracking-wider shadow-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z" />
                        </svg>
                        Clear Local Cache
                    </button>

                    <!-- Delete Button -->
                    <button id="clear-all-data-btn" class="w-full mt-2 flex items-center justify-center gap-2 bg-white border border-red-200 text-red-600 hover:bg-red-50 hover:border-red-300 transition-all rounded-lg py-2.5 text-xs font-bold uppercase tracking-wider shadow-sm group">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-red-400 group-hover:text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                        Delete Cloud Data
                    </button>
                </div>
            </div>
            
            <!-- CSV Upload Section -->
            <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 flex-1 flex flex-col z-0">
                <h2 class="text-gray-800 font-bold text-sm mb-3 flex items-center gap-2 uppercase tracking-wide shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-colgate-blue" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    Data Import
                </h2>
                
                <div class="flex-1 flex flex-col justify-center">
                    <label class="block w-full cursor-pointer hover:bg-gray-50 transition-colors border border-dashed border-gray-300 rounded-lg p-6 text-center h-full flex flex-col items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-gray-300 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        <span class="text-xs font-semibold text-gray-500">Click to Select CSV</span>
                        <input type="file" id="csv-upload" accept=".csv" class="hidden"/>
                    </label>
                    <div id="file-name-display" class="hidden text-[10px] text-colgate-blue font-bold mt-2 text-center truncate"></div>

                    <button id="upload-csv-btn" class="w-full mt-3 bg-colgate-blue text-white py-2 rounded-lg text-xs font-bold hover:bg-blue-900 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed shadow-md shadow-blue-100" disabled>
                        UPLOAD DATA
                    </button>
                    <p id="upload-status" class="text-[10px] mt-2 text-center text-gray-400 font-medium shrink-0">Req: Lat, Lng, Route, Outlet Name</p>
                </div>
            </div>
        </div>

        <!-- Right Column: Map & Info -->
        <div class="lg:col-span-9 flex flex-col gap-4 h-full">

            <!-- Top Row: Status Card & KPI Cards -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 shrink-0">
                
                <!-- Status/Info Card -->
                <div id="info-card" class="bg-colgate-blue rounded-xl p-4 text-white shadow-md flex flex-col justify-center relative overflow-hidden group">
                    <div class="absolute right-0 top-0 w-16 h-16 bg-white/10 rounded-bl-full -mr-4 -mt-4 transition-transform group-hover:scale-110"></div>
                    <h3 id="card-title" class="font-bold text-sm relative z-10">Welcome</h3>
                    <p id="card-detail" class="text-blue-100 text-xs opacity-80 mt-1 relative z-10 truncate">
                        Large Data Mode Ready
                    </p>
                </div>
                
                <!-- KPI 1: Active Outlets -->
                <div class="kpi-card kpi-red rounded-xl p-4 shadow-sm flex items-center justify-between">
                    <div>
                        <p class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Total Outlets</p>
                        <h4 id="kpi-outlets" class="text-2xl font-extrabold text-gray-800 mt-0.5">0</h4>
                    </div>
                    <div class="h-8 w-8 bg-red-50 rounded-lg flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-colgate-red" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </div>
                </div>

                <!-- KPI 2: Route Coverage -->
                <div class="kpi-card kpi-blue rounded-xl p-4 shadow-sm flex items-center justify-between">
                    <div>
                        <p class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Route Coverage</p>
                        <h4 id="kpi-distance" class="text-2xl font-extrabold text-gray-800 mt-0.5">0 <span class="text-xs font-semibold text-gray-400">km</span></h4>
                    </div>
                    <div class="h-8 w-8 bg-blue-50 rounded-lg flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-colgate-blue" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                        </svg>
                    </div>
                </div>
            </div>

            <!-- Map Container -->
            <div class="relative group rounded-xl overflow-hidden shadow-lg border-2 border-white flex-1 flex flex-col">
                <div id="map" class="flex-1"></div>
                <!-- Controls overlay -->
                <div class="absolute bottom-4 left-4 z-[400] bg-white/90 backdrop-blur-sm px-3 py-1.5 rounded-lg border border-gray-100 shadow-sm text-[10px] text-gray-500 font-bold tracking-wider pointer-events-none">
                    OUTLET MAPPER v1.0
                </div>
            </div>

        </div>

        <!-- Invalid/Outside Region Section -->
        <div id="invalid-box" class="lg:col-span-12 hidden bg-white border border-red-100 rounded-xl p-4 shadow-sm mt-2">
            <div class="flex items-center gap-3 mb-3 border-b border-red-100 pb-2">
                <div class="h-8 w-8 bg-red-50 rounded-full flex items-center justify-center shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-colgate-red" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div>
                    <h3 id="invalid-header" class="text-colgate-red font-bold text-sm uppercase tracking-wide">Data Anomalies</h3>
                    <p class="text-[10px] text-gray-500">Outlets with coordinates outside Bangladesh (Lat: 20-29, Lng: 86-95)</p>
                </div>
            </div>
            
            <!-- Horizontal Scrolling List -->
            <div id="invalid-list" class="flex gap-3 overflow-x-auto custom-scrollbar pb-2">
                <!-- List items will be injected here -->
            </div>
        </div>

    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script type="module">
    // --- 1. FIREBASE IMPORTS & SETUP ---
    // We use the CDN links because this is a standalone HTML file
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
    import { 
        getFirestore, 
        collection, 
        getDocs, 
        writeBatch, 
        doc,
        deleteDoc 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // --- YOUR SPECIFIC CONFIGURATION ---
    const firebaseConfig = {
        apiKey: "AIzaSyAmkGBVv9Jfn1Lczatm7gkxef8INmifJCA",
        authDomain: "colgate-map.firebaseapp.com",
        projectId: "colgate-map",
        storageBucket: "colgate-map.firebasestorage.app",
        messagingSenderId: "1023087510822",
        appId: "1:1023087510822:web:46be575c04ad29a6612de7",
        measurementId: "G-P81869T4TX"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app); // Analytics initialized
    const db = getFirestore(app);        // Firestore Database initialized
    
    const COLLECTION_NAME = "outlets";
    
    // --- 0. INDEXEDDB SETUP (Replaces localStorage for large data) ---
    const DB_NAME = 'OutletTrackerLocalDB';
    const STORE_NAME = 'local_cache';
    const DB_VERSION = 1;

    const initLocalDB = () => {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject("Local DB failed to open");
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = (event) => resolve(event.target.result);
        });
    };

    const saveToLocalCache = async (data) => {
        try {
            const db = await initLocalDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            store.put(data, 'outlets_data');
            return new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        } catch (e) {
            console.error("Local Save Error:", e);
        }
    };

    const loadFromLocalCache = async () => {
        try {
            const db = await initLocalDB();
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const request = store.get('outlets_data');
            return new Promise((resolve) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve(null);
            });
        } catch (e) {
            return null;
        }
    };

    const clearLocalCache = async () => {
        const db = await initLocalDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        tx.objectStore(STORE_NAME).clear();
    };

    // --- GLOBAL VARIABLES ---
    let map;
    let markerLayer = L.featureGroup(); 
    let polylineLayer = L.layerGroup();
    let allOutlets = [];
    let selectedRoutes = new Set(); 

    // DOM Elements
    const infoCard = document.getElementById('info-card');
    const cardTitle = document.getElementById('card-title');
    const cardDetail = document.getElementById('card-detail');
    const invalidBox = document.getElementById('invalid-box');
    const invalidList = document.getElementById('invalid-list');
    const invalidHeader = document.getElementById('invalid-header'); 
    const searchInput = document.getElementById('search-input');
    const filterArea = document.getElementById('filter-area');
    const filterTerritory = document.getElementById('filter-territory');
    const filterTown = document.getElementById('filter-town');
    const routeBtn = document.getElementById('route-multiselect-btn');
    const routeList = document.getElementById('route-dropdown-list');
    const routeBtnText = document.getElementById('route-btn-text');
    const clearFiltersBtn = document.getElementById('clear-filters-btn');
    const clearDataBtn = document.getElementById('clear-all-data-btn');
    const clearLocalBtn = document.getElementById('clear-local-data-btn');
    const syncBtn = document.getElementById('sync-btn');
    const csvUpload = document.getElementById('csv-upload');
    const fileNameDisplay = document.getElementById('file-name-display');
    const uploadCsvBtn = document.getElementById('upload-csv-btn');
    const uploadStatus = document.getElementById('upload-status');
    const kpiOutlets = document.getElementById('kpi-outlets');
    const kpiDistance = document.getElementById('kpi-distance');
    const connectionText = document.getElementById('connection-text');

    // --- 2. FIRESTORE FUNCTIONS (Cloud Logic) ---

    // Fetch all data
    const loadDataFromFirestore = async () => {
        try {
            const querySnapshot = await getDocs(collection(db, COLLECTION_NAME));
            const data = [];
            querySnapshot.forEach((doc) => {
                data.push({ id: doc.id, ...doc.data() });
            });
            return data;
        } catch (error) {
            console.error("Error getting documents: ", error);
            throw error;
        }
    };

    // Save Data (Batched)
    const saveDataToFirestore = async (newRecords) => {
        const BATCH_SIZE = 450; 
        const chunks = [];
        
        for (let i = 0; i < newRecords.length; i += BATCH_SIZE) {
            chunks.push(newRecords.slice(i, i + BATCH_SIZE));
        }

        let processedCount = 0;

        for (const chunk of chunks) {
            const batch = writeBatch(db);
            chunk.forEach(record => {
                const newDocRef = doc(collection(db, COLLECTION_NAME));
                batch.set(newDocRef, record);
            });
            
            await batch.commit();
            processedCount += chunk.length;
            uploadStatus.textContent = `Syncing... (${processedCount} / ${newRecords.length})`;
        }
    };

    // Delete All Data (Batched)
    const clearDataFromFirestore = async () => {
        const querySnapshot = await getDocs(collection(db, COLLECTION_NAME));
        const BATCH_SIZE = 450;
        const docs = querySnapshot.docs;
        
        const chunks = [];
        for (let i = 0; i < docs.length; i += BATCH_SIZE) {
            chunks.push(docs.slice(i, i + BATCH_SIZE));
        }

        for (const chunk of chunks) {
            const batch = writeBatch(db);
            chunk.forEach(docSnap => {
                batch.delete(docSnap.ref);
            });
            await batch.commit();
        }
    };

    // --- 3. APP LOGIC (Updated with Caching) ---

    const updateUIWithData = (data, source) => {
        if(connectionText) connectionText.textContent = source;
        
        if (data.length > 0) {
            cardTitle.textContent = "Data Loaded";
            // Updated to allow HTML for the source color coding
            cardDetail.innerHTML = `${data.length.toLocaleString()} records.<br><span class="text-[10px] ${source.includes('Unsynced') ? 'text-red-300' : 'text-green-300'} opacity-80">Source: ${source}</span>`;
            
            const areas = new Set(data.map(d => d.area_name).filter(Boolean));
            updateSelect(filterArea, areas, filterArea.value);
            updateCascadingFilters(0);
        } else {
            cardTitle.textContent = "No Data";
            cardDetail.textContent = "Upload a CSV to save data.";
        }
    };

    const loadData = async (forceRefresh = false) => {
        // 1. Try Local Cache First (Quota Saver)
        if (!forceRefresh) {
            const cachedData = await loadFromLocalCache();
            if (cachedData && cachedData.length > 0) {
                allOutlets = cachedData;
                console.log("Loaded from local IndexedDB");
                updateUIWithData(allOutlets, "Local Cache");
                return; // EXIT EARLY - Do not hit Firestore
            }
        }

        // 2. Fetch from Cloud if no cache or forced
        try {
            cardDetail.textContent = "Connecting to Cloud...";
            if(connectionText) connectionText.textContent = "Fetching...";
            
            allOutlets = await loadDataFromFirestore();
            
            // 3. Save to Cache
            await saveToLocalCache(allOutlets);
            
            updateUIWithData(allOutlets, "Cloud DB");

        } catch (e) {
            console.error("Firestore Error", e);
            
            // QUOTA EXCEEDED HANDLING
            if (e.code === 'resource-exhausted') {
                alert("⚠️ Quota Exceeded ⚠️\n\nYou have hit the free tier limit for Firebase reads today.\n\nTrying to load any available cached data...");
                const cachedData = await loadFromLocalCache();
                if (cachedData) {
                    allOutlets = cachedData;
                    updateUIWithData(allOutlets, "Cache (Quota Limit)");
                    return;
                }
            }

            cardTitle.textContent = "Connection Error";
            cardDetail.textContent = e.code || "Check console.";
        }
    };

    // --- NEW: Handle Sync Button Click ---
    const handleSyncClick = async () => {
        // If we have local data, ask if user wants to upload it
        if (allOutlets.length > 0) {
            const userChoice = confirm(`You have ${allOutlets.length.toLocaleString()} records loaded locally.\n\n[OK] = Upload these to Cloud Firestore\n[Cancel] = Download fresh data from Cloud`);
            
            if (userChoice) {
                // User chose to UPLOAD
                try {
                    const btn = document.getElementById('sync-btn');
                    const originalText = btn.innerHTML;
                    btn.innerHTML = "Uploading...";
                    btn.disabled = true;
                    
                    await saveDataToFirestore(allOutlets);
                    
                    alert("Successfully uploaded to Cloud!");
                    updateUIWithData(allOutlets, "Cloud (Synced)");
                    
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                } catch (e) {
                    console.error(e);
                    alert("Upload failed: " + e.message);
                    document.getElementById('sync-btn').disabled = false;
                }
                return;
            }
        }
        
        // If no local data OR user clicked Cancel, we fetch from cloud
        loadData(true);
    };

    const clearLocalDataOnly = async () => {
        if(!confirm("This will clear data stored in your browser. It will NOT affect Cloud data. Continue?")) return;
        
        try {
            await clearLocalCache();
            // Just in case anything legacy is left
            localStorage.removeItem('outlet_tracker_data_v1'); 
            
            // Clear memory
            allOutlets = [];
            markerLayer.clearLayers();
            polylineLayer.clearLayers();
            selectedRoutes.clear();
            
            // Reset UI
            kpiOutlets.textContent = "0";
            kpiDistance.innerHTML = `0 <span class="text-xs font-semibold text-gray-400">km</span>`;
            invalidList.innerHTML = '';
            invalidBox.classList.add('hidden');
            updateSelect(filterArea, new Set(), "");
            updateSelect(filterTerritory, new Set(), "");
            updateSelect(filterTown, new Set(), "");
            updateRouteMultiSelect(new Set());
            
            cardTitle.textContent = "Local Cache Cleared";
            cardDetail.textContent = "Browser storage empty. Cloud data safe.";
            if(connectionText) connectionText.textContent = "Disconnected";
            
        } catch(e) {
            console.error(e);
            alert("Error clearing local data");
        }
    };

    const clearAllData = async () => {
        if(!confirm("WARNING: This will delete ALL data in the Cloud Database. This affects all users. Continue?")) {
            return;
        }

        try {
            const btn = document.getElementById('clear-all-data-btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = "Deleting...";
            btn.disabled = true;
            cardDetail.textContent = "Deleting from Cloud...";

            await clearDataFromFirestore();
            
            // Clear local state & cache
            await clearLocalCache();
            allOutlets = [];
            markerLayer.clearLayers();
            polylineLayer.clearLayers();
            selectedRoutes.clear();
            
            // Reset UI
            kpiOutlets.textContent = "0";
            kpiDistance.innerHTML = `0 <span class="text-xs font-semibold text-gray-400">km</span>`;
            invalidList.innerHTML = '';
            invalidBox.classList.add('hidden');
            updateSelect(filterArea, new Set(), "");
            updateSelect(filterTerritory, new Set(), "");
            updateSelect(filterTown, new Set(), "");
            updateRouteMultiSelect(new Set());
            
            cardTitle.textContent = "Cleared";
            cardDetail.textContent = "Database is now empty.";
            
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            alert("All cloud data has been deleted successfully.");
            
        } catch (e) {
            console.error("Delete Error:", e);
            alert("Failed to delete data: " + e.message);
            const btn = document.getElementById('clear-all-data-btn');
            btn.innerHTML = originalText; 
            btn.disabled = false;
        }
    }

    // --- 4. MAP & UI LOGIC (Standard) ---
    const initMap = () => {
        if (typeof L === 'undefined') {
            document.getElementById('map').innerHTML = '<div class="text-center text-red-500 p-8 text-xs">Map service failed.</div>';
            return; 
        }

        const southWest = L.latLng(18.0, 86.0); 
        const northEast = L.latLng(29.0, 95.0);
        const bounds = L.latLngBounds(southWest, northEast);

        map = L.map('map', {
            center: [23.8103, 90.4125],
            zoom: 7,
            minZoom: 6,
            maxBounds: bounds,
            maxBoundsViscosity: 0.8,
            zoomControl: false 
        });
        
        L.control.zoom({ position: 'topright' }).addTo(map);

        // --- MAP LAYERS ---
        const osmStandard = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap',
            maxZoom: 19
        }).addTo(map); // Default

        const googleStreets = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',{
            maxZoom: 20,
            subdomains:['mt0','mt1','mt2','mt3'],
            attribution: '&copy; Google'
        });

        const googleHybrid = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',{
            maxZoom: 20,
            subdomains:['mt0','mt1','mt2','mt3'],
            attribution: '&copy; Google'
        });
        
        const esriSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri',
            maxZoom: 19
        });

        const baseMaps = {
            "Standard": osmStandard,
            "Google Streets": googleStreets,
            "Google Hybrid": googleHybrid,
            "Esri Satellite": esriSatellite
        };

        const overlayMaps = {
            "Outlets": markerLayer,
            "Routes": polylineLayer
        };

        // Add Layer Control to Bottom Right
        L.control.layers(baseMaps, overlayMaps, { position: 'bottomright' }).addTo(map);

        markerLayer.addTo(map); 
        polylineLayer.addTo(map);

        document.querySelector('.leaflet-control-container').style.visibility = 'visible';
        loadData(); 
    };

    const updateSelect = (selectElement, values, currentValue) => {
        const oldVal = currentValue || selectElement.value;
        const firstOption = selectElement.options[0];
        selectElement.innerHTML = '';
        selectElement.appendChild(firstOption);

        Array.from(values).sort().forEach(value => {
            const option = document.createElement('option');
            option.value = value;
            option.textContent = value;
            selectElement.appendChild(option);
        });

        if (values.has(oldVal)) selectElement.value = oldVal;
        else selectElement.value = "";
    };

    const updateRouteMultiSelect = (routesSet) => {
        routeList.innerHTML = '';
        selectedRoutes.clear();
        routeBtnText.textContent = "All Routes";

        if (routesSet.size === 0) {
            routeList.innerHTML = '<div class="text-xs text-gray-400 text-center py-2">No routes found</div>';
            return;
        }

        const sortedRoutes = Array.from(routesSet).sort();

        sortedRoutes.forEach(route => {
            const label = document.createElement('label');
            label.className = 'flex items-center gap-2 p-2 hover:bg-gray-50 cursor-pointer rounded';
            
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'route-checkbox hidden'; 
            input.value = route;
            
            const customCheck = document.createElement('div');
            customCheck.className = 'w-4 h-4 border border-gray-300 rounded flex items-center justify-center bg-white transition-colors';
            customCheck.innerHTML = `<svg class="w-3 h-3 text-white hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg>`;

            const span = document.createElement('span');
            span.className = 'text-xs text-gray-700';
            span.textContent = route;

            label.appendChild(input);
            label.appendChild(customCheck);
            label.appendChild(span);
            
            input.addEventListener('change', (e) => {
                if (e.target.checked) selectedRoutes.add(e.target.value);
                else selectedRoutes.delete(e.target.value);
                
                if (selectedRoutes.size === 0) routeBtnText.textContent = "All Routes";
                else if (selectedRoutes.size === 1) routeBtnText.textContent = Array.from(selectedRoutes)[0];
                else routeBtnText.textContent = `${selectedRoutes.size} Routes Selected`;
                
                applyLocalFilters();
            });

            routeList.appendChild(label);
        });
    };

    const updateCascadingFilters = (changedLevel) => {
        const fArea = filterArea.value;
        const fTerritory = filterTerritory.value;
        const fTown = filterTown.value;

        if (changedLevel <= 0) {
            let areaOutlets = allOutlets;
            if (fArea) areaOutlets = areaOutlets.filter(d => d.area_name === fArea);
            const territories = new Set(areaOutlets.map(d => d.territory_name).filter(Boolean));
            updateSelect(filterTerritory, territories, filterTerritory.value);
        }

        if (changedLevel <= 1) {
            let townOutlets = allOutlets;
            if (filterArea.value) townOutlets = townOutlets.filter(d => d.area_name === filterArea.value);
            if (filterTerritory.value) townOutlets = townOutlets.filter(d => d.territory_name === filterTerritory.value);
            const towns = new Set(townOutlets.map(d => d.town_name).filter(Boolean));
            updateSelect(filterTown, towns, filterTown.value);
        }

        if (changedLevel <= 2) {
            let routeOutlets = allOutlets;
            if (filterArea.value) routeOutlets = routeOutlets.filter(d => d.area_name === filterArea.value);
            if (filterTerritory.value) routeOutlets = routeOutlets.filter(d => d.territory_name === filterTerritory.value);
            if (filterTown.value) routeOutlets = routeOutlets.filter(d => d.town_name === filterTown.value);
            const routes = new Set(routeOutlets.map(d => d.route).filter(Boolean));
            updateRouteMultiSelect(routes); 
        }
        applyLocalFilters();
    };

    const applyLocalFilters = () => {
        const searchTerm = searchInput.value.toLowerCase().trim();
        const fArea = filterArea.value;
        const fTerritory = filterTerritory.value;
        const fTown = filterTown.value;

        const filteredData = allOutlets.filter(item => {
            if (fArea && item.area_name !== fArea) return false;
            if (fTerritory && item.territory_name !== fTerritory) return false;
            if (fTown && item.town_name !== fTown) return false;
            if (selectedRoutes.size > 0 && !selectedRoutes.has(item.route)) return false;

            if (searchTerm) {
                const searchString = `${item.outletName} ${item.route} ${item.outlet_code || ''} ${item.town_name || ''}`.toLowerCase();
                if (!searchString.includes(searchTerm)) return false;
            }
            return true;
        });

        const validMapData = [];
        const invalidListData = [];

        filteredData.forEach(item => {
            if (item.lat >= 20 && item.lat <= 29 && item.lng >= 86 && item.lng <= 95) {
                validMapData.push(item);
            } else {
                invalidListData.push(item);
            }
        });

        renderMarkers(validMapData);
        renderInvalidList(invalidListData);
    };

    const renderMarkers = (dataToRender) => {
        markerLayer.clearLayers(); 
        polylineLayer.clearLayers(); 
        kpiOutlets.textContent = dataToRender.length.toLocaleString();

        // Removed the limit of 2000. Now rendering ALL data.
        const renderSet = dataToRender;

        // Removed the warning message about limited data since we are showing all.

        renderSet.forEach(data => {
            const marker = L.circleMarker([data.lat, data.lng], {
                radius: 5,
                fillColor: "#E01933", 
                color: "#FFFFFF",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(markerLayer);

            marker.bindPopup(`<div style="color:#E01933; font-weight:bold; font-size:12px">${data.outletName}</div><div style="font-size:10px; color:#666">${data.route}</div>`);
            
            marker.on('click', () => {
                let detailHtml = `<span class="opacity-75">Outlet:</span> <b>${data.outletName}</b>`;
                if(data.route) detailHtml += `<br><span class="opacity-75">Route:</span> <b>${data.route}</b>`;
                cardTitle.textContent = "Outlet Details";
                cardDetail.innerHTML = detailHtml;
            });
        });

        // Only calculate route lines if we aren't displaying a massive amount of data to prevent browser crash
        // Increased limit slightly but kept safety check for complex geometry calculations
        if (dataToRender.length < 5000) {
            const routeGroups = {};
            dataToRender.forEach(item => {
                const routeName = item.route || 'Unassigned';
                if (!routeGroups[routeName]) routeGroups[routeName] = [];
                routeGroups[routeName].push(item);
            });

            let totalMeters = 0;
            Object.entries(routeGroups).forEach(([route, items]) => {
                if (items.length < 2) return;
                
                // --- OPTIMIZATION: Sort points by Nearest Neighbor to fix zig-zag distance errors ---
                // This reorders the list to create a logical path instead of following CSV row order
                const sortedItems = [items[0]];
                const remaining = items.slice(1);
                
                while(remaining.length > 0) {
                    const last = sortedItems[sortedItems.length - 1];
                    let nearestIdx = 0;
                    let minDst = Infinity;
                    
                    // Find closest remaining point
                    for(let i=0; i<remaining.length; i++) {
                        const dist = Math.pow(last.lat - remaining[i].lat, 2) + Math.pow(last.lng - remaining[i].lng, 2);
                        if(dist < minDst) {
                            minDst = dist;
                            nearestIdx = i;
                        }
                    }
                    sortedItems.push(remaining.splice(nearestIdx, 1)[0]);
                }
                
                const latlngs = sortedItems.map(d => [d.lat, d.lng]);

                for(let i = 0; i < latlngs.length - 1; i++) {
                    const p1 = L.latLng(latlngs[i]);
                    const p2 = L.latLng(latlngs[i+1]);
                    totalMeters += p1.distanceTo(p2);
                }

                if (latlngs.length > 1) {
                    L.polyline(latlngs, {
                        color: '#002169', 
                        weight: 2,
                        opacity: 0.5,
                        dashArray: '4, 4', 
                        lineJoin: 'round'
                    }).addTo(polylineLayer).bindPopup(`Route: ${route}`);
                }
            });
            const totalKm = (totalMeters / 1000).toFixed(1);
            kpiDistance.innerHTML = `${totalKm} <span class="text-xs font-semibold text-gray-400">km</span>`;
        } else {
            kpiDistance.innerHTML = `- <span class="text-xs font-semibold text-gray-400">km</span>`;
        }

        if (renderSet.length > 0) {
            try {
                const bounds = markerLayer.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [20, 20], maxZoom: 14 });
                }
            } catch (e) { }
        }
    };

    const renderInvalidList = (dataList) => {
        invalidList.innerHTML = ''; 
        if (dataList.length > 0) {
            invalidBox.classList.remove('hidden');
            invalidHeader.textContent = `Data Anomalies (${dataList.length})`;
            const displayList = dataList.slice(0, 100);
            displayList.forEach(data => {
                const item = document.createElement('div');
                item.className = 'invalid-list-item flex-shrink-0 w-64 bg-red-50 p-2 rounded border border-red-100 text-[10px] text-gray-600';
                item.innerHTML = `
                    <div class="font-bold text-gray-800 truncate">${data.outletName}</div>
                    <div class="flex justify-between mt-1">
                        <span>Route: ${data.route}</span>
                        <span class="font-mono text-red-500">${data.lat.toFixed(2)}, ${data.lng.toFixed(2)}</span>
                    </div>
                `;
                invalidList.appendChild(item);
            });
        } else {
            invalidBox.classList.add('hidden');
        }
    };

    const clearFilters = () => {
        searchInput.value = "";
        filterArea.value = "";
        filterTerritory.value = "";
        filterTown.value = "";
        selectedRoutes.clear();
        routeBtnText.textContent = "All Routes";
        document.querySelectorAll('.route-checkbox').forEach(cb => cb.checked = false);
        updateCascadingFilters(0); 
    };

    const parseCsv = (csvText) => {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return { success: false, message: "CSV empty" };

        const rawHeaders = lines[0].trim().replace(/^\uFEFF/, '').split(',').map(h => h.trim());
        const FIELD_MAPPINGS = {
            lat: ['Outlet Latitude', 'Latitude', 'lat'],
            lng: ['Outlet Longitude', 'Longitude', 'lng'],
            route: ['Route Name', 'route'],
            outletName: ['Outlet Name', 'outletName']
        };

        const detectedHeaders = {};
        for (const [key, aliases] of Object.entries(FIELD_MAPPINGS)) {
            const found = aliases.find(alias => rawHeaders.includes(alias));
            if (found) {
                detectedHeaders[key] = found;
            } else {
                return { success: false, message: `Missing: ${aliases.join(' or ')}` };
            }
        }
        
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].trim().split(',');
            if (values.length < rawHeaders.length) continue; 
            const rawRecord = {};
            rawHeaders.forEach((header, index) => {
                rawRecord[header] = values[index] ? values[index].trim() : '';
            });

            const record = {
                lat: parseFloat(rawRecord[detectedHeaders.lat]),
                lng: parseFloat(rawRecord[detectedHeaders.lng]),
                route: rawRecord[detectedHeaders.route],
                outletName: rawRecord[detectedHeaders.outletName],
                timestamp: new Date().toISOString()
            };

            for (const header of rawHeaders) {
                const isMapped = Object.values(detectedHeaders).includes(header);
                if (!isMapped) {
                    const key = header.toLowerCase().replace(/\s+/g, '_');
                    record[key] = rawRecord[header];
                }
            }

            if (isNaN(record.lat) || isNaN(record.lng) || !record.route || !record.outletName) continue;
            data.push(record);
        }
        return { success: true, data: data };
    };

    const handleCsvUpload = async () => {
        const file = csvUpload.files[0];
        if (!file) return;

        uploadCsvBtn.disabled = true;
        uploadStatus.textContent = "Parsing CSV...";

        const reader = new FileReader();
        reader.onload = async (e) => {
            const parseResult = parseCsv(e.target.result);
            if (!parseResult.success) {
                uploadStatus.textContent = parseResult.message;
                uploadCsvBtn.disabled = false;
                return;
            }
            
            uploadStatus.textContent = `Processing ${parseResult.data.length.toLocaleString()} records locally...`;
            
            try {
                // MODIFIED: Only save locally, DO NOT upload to Firestore yet
                allOutlets = parseResult.data;
                
                // Save to IndexedDB (Reliable storage)
                await saveToLocalCache(allOutlets);
                
                updateUIWithData(allOutlets, "Local (Unsynced)");
                
                uploadStatus.textContent = "Saved to Browser. Click 'Force Cloud Sync' to Upload.";
                csvUpload.value = '';
                fileNameDisplay.classList.add('hidden');
                
                // Re-enable button
                setTimeout(() => { 
                    uploadCsvBtn.disabled = false;
                }, 1000);
                
            } catch (e) {
                console.error(e);
                uploadStatus.textContent = "Local Save Failed";
                uploadCsvBtn.disabled = false;
            }
        };
        reader.readAsText(file);
    };
    
    csvUpload.addEventListener('change', () => {
        if (csvUpload.files.length > 0) {
            uploadCsvBtn.disabled = false;
            fileNameDisplay.textContent = csvUpload.files[0].name;
            fileNameDisplay.classList.remove('hidden');
            uploadStatus.textContent = "Ready to upload";
        }
    });

    uploadCsvBtn.addEventListener('click', handleCsvUpload);
    syncBtn.addEventListener('click', handleSyncClick);
    
    searchInput.addEventListener('input', applyLocalFilters);
    filterArea.addEventListener('change', () => updateCascadingFilters(0));
    filterTerritory.addEventListener('change', () => updateCascadingFilters(1));
    filterTown.addEventListener('change', () => updateCascadingFilters(2));
    
    routeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        routeList.classList.toggle('hidden');
    });

    document.addEventListener('click', (e) => {
        if (!routeBtn.contains(e.target) && !routeList.contains(e.target)) {
            routeList.classList.add('hidden');
        }
    });
    
    clearFiltersBtn.addEventListener('click', clearFilters);
    if(clearLocalBtn) clearLocalBtn.addEventListener('click', clearLocalDataOnly);
    clearDataBtn.addEventListener('click', clearAllData);
    document.addEventListener('DOMContentLoaded', initMap);

</script>
